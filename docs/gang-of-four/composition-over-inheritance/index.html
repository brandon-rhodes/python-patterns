<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Composition Over Inheritance Principle</title>
    <link rel="stylesheet" type="text/css"
          href="../../_static/style.css">
  </head>
  <body>
    
    <p class="motto">
      •
      <a href="/">Home Page</a>
      •
    </p>
    
    <article>
      <section id="the-composition-over-inheritance-principle">
<h1>The Composition Over Inheritance Principle<a class="headerlink" href="#the-composition-over-inheritance-principle" title="Link to this heading">¶</a></h1>
<p><em>A principle from the</em> <a class="reference internal" href="../"><span class="doc">Gang of Four book</span></a></p>
<div class="admonition-verdict admonition">
<p class="admonition-title">Verdict</p>
<p>In Python as in other programming languages,
this grand principle encourages software architects
to escape from Object Orientation
and enjoy the simpler practices
of Object Based programming instead.</p>
</div>
<p>This is the second principle propounded
by the <a class="reference internal" href="../"><span class="doc">Gang of Four book</span></a> at the very beginning,
in its “Introduction” chapter.
The principle is so important that they display it indented and in italics,
like this:</p>
<blockquote>
<div><p><em>Favor object composition over class inheritance.</em></p>
</div></blockquote>
<p>Let’s take a single design problem
and watch how this principle works itself out
through several of the classic Gang of Four design patterns.
Each design pattern will assemble simple classes,
unburdened by inheritance,
into an elegant runtime solution.</p>
<section id="problem-the-subclass-explosion">
<h2>Problem: the subclass explosion<a class="headerlink" href="#problem-the-subclass-explosion" title="Link to this heading">¶</a></h2>
<p>A crucial weakness of inheritance as a design strategy
is that a class often needs to be specialized
along several different design axes at once,
leading to what the Gang of Four call
“a proliferation of classes” in their Bridge chapter
and
“an explosion of subclasses to support every combination”
in their Decorator chapter.</p>
<p>Python’s <a class="reference external" href="https://docs.python.org/3/library/logging.html">logging module</a>
is a good example in the Standard Library itself
of a module that follows the Composition Over Inheritance principle,
so let’s use logging as our example.
Imagine a base logging class
that has gradually gained subclasses
as developers needed to send log messages to new destinations.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">syslog</span>

<span class="c1"># The initial class.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="c1"># Two more classes, that send messages elsewhere.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SocketLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">((</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SyslogLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem arises when this first axis of design is joined by another.
Let’s imagine that log messages now need to be filtered —
some users only want to see messages with the word “Error” in them,
and a developer responds with a new subclass of <code class="docutils literal notranslate"><span class="pre">Logger</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># New design direction: filtering messages.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="c1"># It works.</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">FilteredLogger</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Ignored: this is not important&#39;</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: but you want to see this&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Error: but you want to see this
</pre></div>
</div>
<p>The trap has now been laid,
and will be sprung the moment the application
needs to filter messages
but write them to a socket instead of a file.
None of the existing classes covers that case.
If the developer plows on ahead with subclassing
and creates a <code class="docutils literal notranslate"><span class="pre">FilteredSocketLogger</span></code>
that combines the features of both classes,
then the subclass explosion is underway.</p>
<p>Maybe the programmer will get lucky
and no further combinations will be needed.
But in the general case the application will wind up with 3×2=6 classes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Logger</span>            <span class="n">FilteredLogger</span>
<span class="n">SocketLogger</span>      <span class="n">FilteredSocketLogger</span>
<span class="n">SyslogLogger</span>      <span class="n">FilteredSyslogLogger</span>
</pre></div>
</div>
<p>The total number of classes will increase geometrically
if <em>m</em> and <em>n</em> both continue to grow.
This is the “proliferation of classes”
and “explosion of subclasses”
that the Gang of Four want to avoid.</p>
<p>The solution is to recognize
that a class responsible for both filtering messages and logging messages
is too complicated.
In modern Object Oriented practice,
it would be accused of violating the “Single Responsibility Principle.”</p>
<p>But how can we distribute
the two features of message filtering and message output
across different classes?</p>
</section>
<section id="solution-1-the-adapter-pattern">
<h2>Solution #1: The Adapter Pattern<a class="headerlink" href="#solution-1-the-adapter-pattern" title="Link to this heading">¶</a></h2>
<p>One solution is the Adapter Pattern:
to decide that the original logger class
doesn’t need to be improved,
because any mechanism for outputting messages
can be wrapped up to look like the file object that the logger is expecting.</p>
<ol class="arabic simple">
<li><p>So we keep the original <code class="docutils literal notranslate"><span class="pre">Logger</span></code>.</p></li>
<li><p>And we also keep the <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code>.</p></li>
<li><p>But instead of creating destination-specific subclasses,
we adapt each destination to the behavior of a file
and then pass the adapter to a <code class="docutils literal notranslate"><span class="pre">Logger</span></code> as its output file.</p></li>
</ol>
<p>Here are adapters for each of the other two outputs:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">socket</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FileLikeSocket</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message_and_newline</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">message_and_newline</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FileLikeSyslog</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message_and_newline</span><span class="p">):</span>
        <span class="n">message</span> <span class="o">=</span> <span class="n">message_and_newline</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>Python encourages duck typing,
so an adapter’s only responsibility is to offer the right methods —
our adapters, for example, are exempt from the need
to inherit from either the classes they wrap
or from the <code class="docutils literal notranslate"><span class="pre">file</span></code> type they are imitating.
They are also under no obligation to re-implement
the full slate of more than a dozen methods that a real file offers.
Just as it’s not important that a duck can walk if all you need is a quack,
our adapters only need to implement the two file methods
that the <code class="docutils literal notranslate"><span class="pre">Logger</span></code> really uses.</p>
<p>And so the subclass explosion is avoided!
Logger objects and adapter objects
can be freely mixed and matched at runtime
without the need to create any further classes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sock1</span><span class="p">,</span> <span class="n">sock2</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socketpair</span><span class="p">()</span>

<span class="n">fs</span> <span class="o">=</span> <span class="n">FileLikeSocket</span><span class="p">(</span><span class="n">sock1</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">FilteredLogger</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Warning: message number one&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: message number two&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The socket received: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sock2</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">512</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The socket received: b&#39;Error: message number two\n&#39;
</pre></div>
</div>
<p>Note that it was only for the sake of example
that the <code class="docutils literal notranslate"><span class="pre">FileLikeSocket</span></code> class is written out above —
in real life that adapter comes built-in to Python’s Standard Library.
Simply call any socket’s <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.makefile"><code class="docutils literal notranslate"><span class="pre">makefile()</span></code></a> method
to receive a complete adapter that makes the socket look like a file.</p>
</section>
<section id="solution-2-the-bridge-pattern">
<h2>Solution #2: The Bridge Pattern<a class="headerlink" href="#solution-2-the-bridge-pattern" title="Link to this heading">¶</a></h2>
<p>The Bridge Pattern splits a class’s behavior
between an outer “abstraction” object that the caller sees
and an “implementation” object that’s wrapped inside.
We can apply the Bridge Pattern to our logging example
if we make the (perhaps slightly arbitrary) decision
that filtering belongs out in the “abstraction” class
while output belongs in the “implementation” class.</p>
<p>As in the Adapter case,
a separate echelon of classes now governs writing.
But instead of having to contort our output classes
to match the interface of a Python <code class="docutils literal notranslate"><span class="pre">file</span></code> object —
which required the awkward maneuver
of adding a newline in the logger
that sometimes had to be removed again in the adapter —
we now get to define the interface of the wrapped class ourselves.</p>
<p>So let’s design the inner “implementation” object to accept a raw message,
rather than needing a newline appended,
and reduce the interface to only a single method <code class="docutils literal notranslate"><span class="pre">emit()</span></code>
instead of also having to support a <code class="docutils literal notranslate"><span class="pre">flush()</span></code> method
that was usually a no-op.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The “abstractions” that callers will see.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span> <span class="o">=</span> <span class="n">handler</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">handler</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="c1"># The “implementations” hidden behind the scenes.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FileHandler</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SocketHandler</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">((</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SyslogHandler</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>Abstraction objects and implementation objects
can now be freely combined at runtime:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="o">=</span> <span class="n">FileHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">FilteredLogger</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Ignored: this will not be logged&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Error: this is important
</pre></div>
</div>
<p>This presents more symmetry than the Adapter.
Instead of file output being native to the <code class="docutils literal notranslate"><span class="pre">Logger</span></code>
but non-file output requiring an additional class,
a functioning logger is now always built
by composing an abstraction with an implementation.</p>
<p>Once again,
the subclass explosion is avoided
because two kinds of class are composed together at runtime
without requiring either class to be extended.</p>
</section>
<section id="solution-3-the-decorator-pattern">
<h2>Solution #3: The Decorator Pattern<a class="headerlink" href="#solution-3-the-decorator-pattern" title="Link to this heading">¶</a></h2>
<p>What if we wanted to apply two different filters to the same log?
Neither of the above solutions supports multiple filters —
say, one filtering by priority and the other matching a keyword.</p>
<p>Look back at the filters defined in the previous section.
The reason we cannot stack two filters
is that there’s an asymmetry
between the interface they offer and the interface they wrap:
they offer a <code class="docutils literal notranslate"><span class="pre">log()</span></code> method
but call their handler’s <code class="docutils literal notranslate"><span class="pre">emit()</span></code> method.
Wrapping one filter in another would result in an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>
when the outer filter tried to call the inner filter’s <code class="docutils literal notranslate"><span class="pre">emit()</span></code>.</p>
<p>If we instead pivot our filters and handlers to offering the same interface,
so that they all alike offer a <code class="docutils literal notranslate"><span class="pre">log()</span></code> method,
then we have arrived at the Decorator Pattern:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The loggers all perform real output.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FileLogger</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SocketLogger</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">((</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SyslogLogger</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

<span class="c1"># The filter calls the same method it offers.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">LogFilter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">logger</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>For the first time,
the filtering code has moved outside of any particular logger class.
Instead, it’s now a stand-alone feature
that can be wrapped around any logger we want.</p>
<p>As with our first two solutions,
filtering can be combined with output at runtime
without building any special combined classes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">log1</span> <span class="o">=</span> <span class="n">FileLogger</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">log2</span> <span class="o">=</span> <span class="n">LogFilter</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">log1</span><span class="p">)</span>

<span class="n">log1</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Noisy: this logger always produces output&#39;</span><span class="p">)</span>

<span class="n">log2</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Ignored: this will be filtered out&#39;</span><span class="p">)</span>
<span class="n">log2</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important and gets printed&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Noisy: this logger always produces output
Error: this is important and gets printed
</pre></div>
</div>
<p>And because Decorator classes are symmetric —
they offer exactly the same interface they wrap —
we can now stack several different filters atop the same log!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">log3</span> <span class="o">=</span> <span class="n">LogFilter</span><span class="p">(</span><span class="s1">&#39;severe&#39;</span><span class="p">,</span> <span class="n">log2</span><span class="p">)</span>

<span class="n">log3</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is bad, but not that bad&#39;</span><span class="p">)</span>
<span class="n">log3</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is pretty severe&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Error: this is pretty severe
</pre></div>
</div>
<p>But note the one place where the symmetry of this design breaks down:
while filters can be stacked,
output routines cannot be combined or stacked.
Log messages can still only be written to one output.</p>
</section>
<section id="solution-4-beyond-the-gang-of-four-patterns">
<h2>Solution #4: Beyond the Gang of Four patterns<a class="headerlink" href="#solution-4-beyond-the-gang-of-four-patterns" title="Link to this heading">¶</a></h2>
<p>Python’s logging module wanted even more flexibility:
not only to support multiple filters,
but to support multiple outputs for a single stream of log messages.
Based on the design of logging modules in other languages —
see <a class="reference external" href="https://www.python.org/dev/peps/pep-0282/">PEP 282</a>’s
“Influences” section for the main inspirations —
the Python logging module
implements its own Composition Over Inheritance pattern.</p>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Logger</span></code> class that callers interact with
doesn’t itself implement either filtering or output.
Instead, it maintains a list of filters and a list of handlers.</p></li>
<li><p>For each log message,
the logger calls each of its filters.
The message is discarded if any filter rejects it.</p></li>
<li><p>For each log message that’s accepted by all the filters,
the logger loops over its output handlers
and asks every one of them to <code class="docutils literal notranslate"><span class="pre">emit()</span></code> the message.</p></li>
</ol>
<p>Or, at least, that’s the core of the idea.
The Standard Library’s logging is in fact more complicated.
For example,
each handler can carry its own list of filters
in addition to those listed by its logger.
And each handler also specifies a minimum message “level”
like <code class="docutils literal notranslate"><span class="pre">INFO</span></code> or <code class="docutils literal notranslate"><span class="pre">WARN</span></code> that,
rather confusingly,
is enforced neither by the handler itself
nor by any of the handler’s filters,
but instead by an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement
buried deep inside the logger where it loops over the handlers.
The total design is thus a bit of a mess.</p>
<p>But we can use the Standard Library logger’s basic insight —
that a logger’s messages
might deserve both multiple filters <em>and</em> multiple outputs —
to decouple filter classes and handler classes entirely:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># There is now only one logger.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Logger</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">handlers</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filters</span> <span class="o">=</span> <span class="n">filters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="o">=</span> <span class="n">handlers</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">filters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
                <span class="n">h</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="c1"># Filters now know only about strings!</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TextFilter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">text</span>

<span class="c1"># Handlers look like “loggers” did in the previous solution.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FileHandler</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SocketHandler</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">((</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SyslogHandler</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that only with this final pivot in our design
do filters really shine forth with the simplicity they deserve.
For the first time,
they accept only a string and return only a verdict.
All of the previous designs
either hid filtering inside one of the logging classes itself,
or saddled filters with additional duties
beyond simply rendering a verdict.</p>
<p>In fact,
the word “log” has dropped entirely away from the name of the filter class,
and for a very important reason:
there’s no longer anything about it that’s specific to logging!
The <code class="docutils literal notranslate"><span class="pre">TextFilter</span></code> is now entirely reusable
in any context that happens to involve strings.
Finally decoupled from the specific concept of logging,
it will be easier to test and maintain.</p>
<p>Again,
as with all Composition Over Inheritance solutions to a problem,
classes are composed at runtime without needing any inheritance:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">TextFilter</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">FileHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="p">([</span><span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="n">h</span><span class="p">])</span>

<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Ignored: this will not be logged&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Error: this is important
</pre></div>
</div>
<p>There’s a crucial lesson here:
design principles like Composition Over Inheritance are,
in the end,
more important than individual patterns like the Adapter or Decorator.
Always follow the principle.
But don’t always feel constrained
to choose a pattern from an official list.
The design at which we’ve now arrived
is both more flexible and easier to maintain
than any of the previous designs,
even though they were based on official Gang of Four patterns
but this final design is not.
Sometimes, yes, you will find an existing Design Pattern
that’s a perfect fit for your problem —
but if not,
your design might be stronger if you move beyond them.</p>
</section>
<section id="dodge-if-statements">
<h2>Dodge: “if” statements<a class="headerlink" href="#dodge-if-statements" title="Link to this heading">¶</a></h2>
<p>I suspect that the above code has startled many readers.
To a typical Python programmer,
such heavy use of classes might look entirely contrived —
an awkward exercise in trying to make old ideas from the 1980s
seem relevant to modern Python.</p>
<p>When a new design requirement appears,
does the typical Python programmer
really go write a new class?
No!
“Simple is better than complex.”
Why add a class,
when an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement will work instead?
A single logger class can gradually accrete conditionals
until it handles all the same cases
as our previous examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Each new feature as an “if” statement.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Logger</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">((</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">syslog</span><span class="o">.</span><span class="n">syslog</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>

<span class="c1"># Works just fine.</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">Logger</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>

<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Warning: not that important&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Error: this is important
</pre></div>
</div>
<p>You may recognize this example
as more typical of the Python design practices
you’ve encountered in real applications.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">if</span></code> statement approach is not entirely without benefit.
This class’s whole range of possible behaviors
can be grasped in a single reading of the code from top to bottom.
The parameter list might look verbose but,
thanks to Python’s optional keyword arguments,
most calls to the class won’t need to provide all four arguments.</p>
<p>(It’s true that this class can handle only one file and one socket,
but that’s an incidental simplification for the sake of readability.
We could easily pivot the <code class="docutils literal notranslate"><span class="pre">file</span></code> and <code class="docutils literal notranslate"><span class="pre">socket</span></code> parameters
to lists named <code class="docutils literal notranslate"><span class="pre">files</span></code> and <code class="docutils literal notranslate"><span class="pre">sockets</span></code>.)</p>
<p>Given that every Python programmer learns <code class="docutils literal notranslate"><span class="pre">if</span></code> quickly,
but can take much longer to understand classes,
it might seem a clear win
for code to rely on the simplest possible mechanism
that will get a feature working.
But let’s balance that temptation by making explicit what’s been lost
by dodging Composition Over Inheritance:</p>
<ol class="arabic simple">
<li><p><strong>Locality.</strong>
Reorganizing the code to use <code class="docutils literal notranslate"><span class="pre">if</span></code> statements
hasn’t been an unmitigated win for readability.
If you are tasked with improving or debugging one particular feature —
say, the support for writing to a socket —
you will find that you can’t read its code all in one place.
The code behind that single feature
is scattered between the initializer’s parameter list,
the initializer’s code,
and the <code class="docutils literal notranslate"><span class="pre">log()</span></code> method itself.</p></li>
<li><p><strong>Deletability.</strong>
An underappreciated property of good design
is that it makes deleting features easy.
Perhaps only veterans of large and mature Python applications
will strongly enough appreciate
the importance of code deletion to a project’s health.
In the case of our class-based solutions,
we can trivially delete a feature like logging to a socket
by removing the <code class="docutils literal notranslate"><span class="pre">SocketHandler</span></code> class and its unit tests
once the application no longer needs it.
By contrast,
deleting the socket feature from the forest of <code class="docutils literal notranslate"><span class="pre">if</span></code> statements
not only requires caution
to avoid breaking adjacent code,
but raises the awkward question of what to do
with the <code class="docutils literal notranslate"><span class="pre">socket</span></code> parameter in the initializer.
Can it be removed?
Not if we need to keep the list of positional parameters consistent —
we would need to retain the parameter,
but raise an exception if it’s ever used.</p></li>
<li><p><strong>Dead code analysis.</strong>
Related to the previous point
is the fact that when we use Composition Over Inheritance,
dead code analyzers
can trivially detect
when the last use of <code class="docutils literal notranslate"><span class="pre">SocketHandler</span></code> in the codebase disappears.
But dead code analysis is often helpless to make a determination like
“you can now remove all the attributes and <code class="docutils literal notranslate"><span class="pre">if</span></code> statements
related to socket output,
because no surviving call to the initializer
passes anything for <code class="docutils literal notranslate"><span class="pre">socket</span></code> other than <code class="docutils literal notranslate"><span class="pre">None</span></code>.”</p></li>
<li><p><strong>Testing.</strong>
One of the strongest signals about code health that our tests provide
is how many lines of irrelevant code have to run
before reaching the line under test.
Testing a feature like logging to a socket is easy
if the test can simply spin up a <code class="docutils literal notranslate"><span class="pre">SocketHandler</span></code> instance,
pass it a live socket,
and ask it to <code class="docutils literal notranslate"><span class="pre">emit()</span></code> a message.
No code runs except code relevant to the feature.
But testing socket logging in our forest of <code class="docutils literal notranslate"><span class="pre">if</span></code> statements
will run at least three times the number of lines of code.
Having to set up a logger
with the right combination of several features
merely to test one of them
is an important warning sign,
that might seem trivial in this small example
but becomes crucial as a system grows larger.</p></li>
<li><p><strong>Efficiency.</strong>
I’m deliberately putting this point last,
because readability and maintainability
are generally more important concerns.
But the design problems with the forest of <code class="docutils literal notranslate"><span class="pre">if</span></code> statements
are also signalled by the approach’s inefficiency.
Even if you want a simple unfiltered log to a single file,
every single message will be forced to run an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement
against every possible feature you could have enabled.
The technique of composition, by contrast,
only runs code for the features you’ve composed together.</p></li>
</ol>
<p>For all of these reasons,
I suggest that the apparent simplicity of the <code class="docutils literal notranslate"><span class="pre">if</span></code> statement forest
is, from the point of view of software design, largely an illusion.
The ability to read the logger top-to-bottom as a single piece of code
comes at the cost of several other kinds of conceptual expense
that will grow sharply with the size of the codebase.</p>
</section>
<section id="dodge-multiple-inheritance">
<h2>Dodge: Multiple Inheritance<a class="headerlink" href="#dodge-multiple-inheritance" title="Link to this heading">¶</a></h2>
<p>Some Python projects
fall short of practicing Composition Over Inheritance
because they are tempted to dodge the principle
by means of a controversial feature of the Python language:
multiple inheritance.</p>
<p>Let’s return to the example code we started with,
where <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code> and <code class="docutils literal notranslate"><span class="pre">SocketLogger</span></code>
were two different subclasses of a base <code class="docutils literal notranslate"><span class="pre">Logger</span></code> class.
In a language that only supported single inheritance,
a <code class="docutils literal notranslate"><span class="pre">FilteredSocketLogger</span></code>
would have to choose
to inherit either from <code class="docutils literal notranslate"><span class="pre">SocketLogger</span></code> or <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code>,
and would then have to duplicate code from the other class.</p>
<p>But Python supports multiple inheritance,
so the new <code class="docutils literal notranslate"><span class="pre">FilteredSocketLogger</span></code>
can list both <code class="docutils literal notranslate"><span class="pre">SocketLogger</span></code> and <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code> as base classes
and inherit from both:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Our original example’s base class and subclasses.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Logger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SocketLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">((</span><span class="n">message</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">file</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="c1"># A class derived through multiple inheritance.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredSocketLogger</span><span class="p">(</span><span class="n">FilteredLogger</span><span class="p">,</span> <span class="n">SocketLogger</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="n">FilteredLogger</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">SocketLogger</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">)</span>

<span class="c1"># Works just fine.</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FilteredSocketLogger</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">,</span> <span class="n">sock1</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Warning: not that important&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The socket received: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sock2</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">512</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The socket received: b&#39;Error: this is important\n&#39;
</pre></div>
</div>
<p>This bears several striking resemblances
to our Decorator Pattern solution.
In both cases:</p>
<ul class="simple">
<li><p>There’s a logger class for each kind of output
(instead of our Adapter’s asymmetry
between writing files directly
but non-files through an adapter).</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">message</span></code> preserves the exact value provided by the caller
(instead of our Adapter’s habit
of replacing it with a file-specific value
by appending a newline).</p></li>
<li><p>The filter and loggers are symmetric
in that they both implement the same method <code class="docutils literal notranslate"><span class="pre">log()</span></code>.
(Our other solutions besides the Decorator
had filter classes offering one method
and output classes offering another).</p></li>
<li><p>The filter never tries to produce output on its own but,
if a message survives filtering,
defers the task of output to other code.</p></li>
</ul>
<p>These close similarities
with our earlier Decorator solution
mean that we can compare it with this new code
to make an unusually sharp comparison
between Composition Over Inheritance and multiple inheritance.
Let’s sharpen the focus still further with a question:</p>
<p><em>If we have thorough unit tests for both the logger and filter,
how confident are we that they will work together?</em></p>
<ol class="arabic">
<li><p>The success of the Decorator example
depends only on the public behaviors of each class:
that the <code class="docutils literal notranslate"><span class="pre">LogFilter</span></code> offers a <code class="docutils literal notranslate"><span class="pre">log()</span></code> method
that in turn calls <code class="docutils literal notranslate"><span class="pre">log()</span></code> on the object it wraps
(which a test can trivially verify using a tiny fake logger),
and that each logger offers a working <code class="docutils literal notranslate"><span class="pre">log()</span></code> method.
As long as our unit tests verify these two public behaviors,
we can’t break composition
without failing our unit tests.</p>
<p>Multiple inheritance, by contrast,
depends on behavior that cannot be verified
by simply instantiating the classes in question.
The public behavior of a <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code>
is that it offers a <code class="docutils literal notranslate"><span class="pre">log()</span></code> method
that both filters and writes to a file.
But multiple inheritance doesn’t merely depend on that public behavior,
but on how that behavior is implemented internally.
Multiple inheritance will work
if the method is deferring to its base class using <code class="docutils literal notranslate"><span class="pre">super()</span></code>,
but not if the method does its own <code class="docutils literal notranslate"><span class="pre">write()</span></code> to the file,
even though either implementation would satisfy the unit test.</p>
<p>A test suite must therefore go beyond unit testing
and perform actual multiple inheritance on the class —
or else monkey patch to verify that <code class="docutils literal notranslate"><span class="pre">log()</span></code> calls <code class="docutils literal notranslate"><span class="pre">super().log()</span></code> —
to guarantee that multiple inheritance keeps working
as future developers work on the code.</p>
</li>
<li><p>Multiple inheritance has introduced a new <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method
because neither base class’s <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method
accepts enough arguments for a combined filter and logger.
That new code needs to be tested,
so at least one test will be necessary
for every new subclass.</p>
<p>You might be tempted to concoct a scheme
to avoid a new <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> for every subclass,
like accepting <code class="docutils literal notranslate"><span class="pre">*args</span></code> and then passing them on to <code class="docutils literal notranslate"><span class="pre">super().__init__()</span></code>.
(If you do pursue that approach,
review the classic essay “<a class="reference external" href="https://fuhm.net/super-harmful/">Python’s Super Considered Harmful</a>”
which argues that only <code class="docutils literal notranslate"><span class="pre">**kw</span></code> is in fact safe.)
The problem with such a scheme is that it hurts readability —
you can no longer figure out what arguments an <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method takes
simply by reading its parameter list.
And type checking tools
will no longer be able to guarantee correctness.</p>
<p>But whether you give each derived class its own <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>
or design them to chain together,
your unit tests of the original <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code> and <code class="docutils literal notranslate"><span class="pre">SocketLogger</span></code>
can’t by themselves guarantee
that the classes initialize correctly when combined.</p>
<p>By contrast,
the Decorator’s design leaves its initializers
happily and strictly orthogonal.
The filter accepts its <code class="docutils literal notranslate"><span class="pre">pattern</span></code>,
the logger accepts its <code class="docutils literal notranslate"><span class="pre">sock</span></code>,
and there is no possible conflict between the two.</p>
</li>
<li><p>Finally,
it’s possible that two classes work fine on their own,
but have class or instance attributes with the same name
that will collide
when the classes are combined through multiple inheritance.</p>
<p>Yes,
our small examples here
make the chance of collision look too small to worry about —
but remember that these examples are merely standing in
for the vastly more complicated classes
you might write in real applications.</p>
<p>Whether the programmer writes tests to guard against collision
by running <code class="docutils literal notranslate"><span class="pre">dir()</span></code> on instances of each class
and checking for attributes they have in common,
or by writing an integration test
for every possible subclass,
the original unit tests of the two separate classes
will once again have failed to guarantee
that they can combine cleanly through multiple inheritance.</p>
</li>
</ol>
<p>For any of these reasons,
the unit tests of two base classes can stay green
even as their ability to be combined through multiple inheritance
is broken.
This means that the Gang of Four’s
“explosion of subclasses to support every combination”
will also afflict your tests.
Only by testing
every combination of <em>m</em>×<em>n</em> base classes in your application
can you make it safe for the application to use such classes at runtime.</p>
<p>In addition to breaking the guarantees of unit testing,
multiple inheritance involves at least three further liabilities.</p>
<ol class="arabic simple" start="4">
<li><p>Introspection is simple in the Decorator case.
Simply <code class="docutils literal notranslate"><span class="pre">print(my_filter.logger)</span></code> or view that attribute in a debugger
to see what sort of output logger is attached.
In the case of multiple inheritance, however,
you can only learn which filter and logger have been combined
by examining the metadata of the class itself —
either by reading its <code class="docutils literal notranslate"><span class="pre">__mro__</span></code>
or subjecting the object to a series of <code class="docutils literal notranslate"><span class="pre">isinstance()</span></code> tests.</p></li>
<li><p>It’s trivial in the Decorator case
to take a live combination of a filter and logger
and at runtime to swap in a different logger
through assignment to the <code class="docutils literal notranslate"><span class="pre">.logger</span></code> attribute —
say, because the user has just toggled a preference
in the application’s interface.
But to do the same in the multiple inheritance case
would require the rather more objectionable maneuver
of overwriting the object’s class.
While changing an object’s class at runtime
is not impossible in a dynamic language like Python,
it’s generally considered a symptom
that software design has gone wrong.</p></li>
<li><p>Finally,
multiple inheritance provides no built-in mechanism
to help the programmer order the base classes correctly.
The <code class="docutils literal notranslate"><span class="pre">FilteredSocketLogger</span></code>
won’t successfully write to a socket if its base classes are swapped and,
as dozens of Stack Overflow questions attest,
Python programmers have perpetual difficultly
with putting third-party base classes in the right order.
The Decorator pattern, by contrast,
makes it obvious which way the classes compose:
the filter’s <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> wants a <code class="docutils literal notranslate"><span class="pre">logger</span></code> object,
but the logger’s <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> doesn’t ask for a <code class="docutils literal notranslate"><span class="pre">filter</span></code>.</p></li>
</ol>
<p>Multiple inheritance, then,
incurs a number of liabilities
without adding a single advantage.
At least in this example,
solving a design problem with inheritance
is strictly worse than a design based on composition.</p>
</section>
<section id="dodge-mixins">
<h2>Dodge: Mixins<a class="headerlink" href="#dodge-mixins" title="Link to this heading">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">FilteredSocketLogger</span></code> in the previous section
needed its own custom <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method
because it needed to accept arguments for both of its base classes.
But it turns out that this liability
can be avoided.
Of course,
in cases where a subclass doesn’t require any extra data,
the problem doesn’t arise.
But even classes that do require extra data
can have it delivered by other means.</p>
<p>We can make the <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code>
more friendly to multiple inheritance
if we provide a default value for <code class="docutils literal notranslate"><span class="pre">pattern</span></code> in the class itself
and then invite callers to customize the attribute directly,
out-of-band of initialization:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Don’t accept a “pattern” during initialization.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredLogger</span><span class="p">(</span><span class="n">Logger</span><span class="p">):</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="c1"># Multiple inheritance is now simpler.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredSocketLogger</span><span class="p">(</span><span class="n">FilteredLogger</span><span class="p">,</span> <span class="n">SocketLogger</span><span class="p">):</span>
    <span class="k">pass</span>  <span class="c1"># This subclass needs no extra code!</span>

<span class="c1"># The caller can just set “pattern” directly.</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FilteredSocketLogger</span><span class="p">(</span><span class="n">sock1</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;Error&#39;</span>

<span class="c1"># Works just fine.</span>

<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Warning: not that important&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important&#39;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The socket received: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">sock2</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">512</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The socket received: b&#39;Error: this is important\n&#39;
</pre></div>
</div>
<p>Having pivoted the <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code>
to an initialization maneuver
that’s orthogonal to that of its base class,
why not push the idea of orthogonality to its logical conclusion?
We can convert the <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code> to a “mixin”
that lives entirely outside the class hierarchy
with which multiple inheritance will combine it.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Simplify the filter by making it a mixin.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilterMixin</span><span class="p">:</span>  <span class="c1"># No base class!</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="ow">in</span> <span class="n">message</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="c1"># Multiple inheritance looks the same as above.</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FilteredLogger</span><span class="p">(</span><span class="n">FilterMixin</span><span class="p">,</span> <span class="n">FileLogger</span><span class="p">):</span>
    <span class="k">pass</span>  <span class="c1"># Again, the subclass needs no extra code.</span>

<span class="c1"># Works just fine.</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">FilteredLogger</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;Error&#39;</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Warning: not that important&#39;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;Error: this is important&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Error: this is important
</pre></div>
</div>
<p>The mixin is conceptually simpler
than the filtered subclass we saw in the last section:
it has no base class that might complicate method resolution order,
so <code class="docutils literal notranslate"><span class="pre">super()</span></code> will always call
the next base class listed in the <code class="docutils literal notranslate"><span class="pre">class</span></code> statement.</p>
<p>A mixin also has a simpler testing story than the equivalent subclass.
Whereas the <code class="docutils literal notranslate"><span class="pre">FilteredLogger</span></code> would need tests
that both run it standalone
and also combine it with other classes,
the <code class="docutils literal notranslate"><span class="pre">FilterMixin</span></code> only needs tests that combine it with a logger.
Because the mixin is by itself incomplete,
a test can’t even be written that runs it standalone.</p>
<p>But all the other liabilities of multiple inheritance still apply.
So while the mixin pattern
does improve the readability and conceptual simplicity
of multiple inheritance,
it’s not a complete solution for its problems.</p>
</section>
<section id="dodge-building-classes-dynamically">
<h2>Dodge: Building classes dynamically<a class="headerlink" href="#dodge-building-classes-dynamically" title="Link to this heading">¶</a></h2>
<p>As we saw in the previous two sections,
neither traditional multiple inheritance nor mixins
solve the Gang of Four’s problem
of “an explosion of subclasses to support every combination” —
they merely avoid code duplication when two classes need to be combined.</p>
<p>Multiple inheritance still requires, in the general case,
“a proliferation of classes” with <em>m</em>×<em>n</em> class statements
that each look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">FilteredSocketLogger</span><span class="p">(</span><span class="n">FilteredLogger</span><span class="p">,</span> <span class="n">SocketLogger</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>But it turns out that Python offers a workaround.</p>
<p>Imagine that our application reads a configuration file
to learn the log filter and log destination it should use,
a file whose contents aren’t known until runtime.
Instead of building all <em>m</em>×<em>n</em> possible classes ahead of time
and then selecting the right one,
we can wait and take advantage of the fact
that Python not only supports the <code class="docutils literal notranslate"><span class="pre">class</span></code> statement
but a builtin <code class="docutils literal notranslate"><span class="pre">type()</span></code> function
that creates new classes dynamically at runtime:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Imagine 2 filtered loggers and 3 output loggers.</span>

<span class="n">filters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;pattern&#39;</span><span class="p">:</span> <span class="n">PatternFilteredLog</span><span class="p">,</span>
    <span class="s1">&#39;severity&#39;</span><span class="p">:</span> <span class="n">SeverityFilteredLog</span><span class="p">,</span>
<span class="p">}</span>
<span class="n">outputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="n">FileLog</span><span class="p">,</span>
    <span class="s1">&#39;socket&#39;</span><span class="p">:</span> <span class="n">SocketLog</span><span class="p">,</span>
    <span class="s1">&#39;syslog&#39;</span><span class="p">:</span> <span class="n">SyslogLog</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># Select the two classes we want to combine.</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;config&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">filter_name</span><span class="p">,</span> <span class="n">output_name</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

<span class="n">filter_cls</span> <span class="o">=</span> <span class="n">filters</span><span class="p">[</span><span class="n">filter_name</span><span class="p">]</span>
<span class="n">output_cls</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="n">output_name</span><span class="p">]</span>

<span class="c1"># Build a new derived class (!)</span>

<span class="n">name</span> <span class="o">=</span> <span class="n">filter_name</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="o">+</span> <span class="n">output_name</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;Log&#39;</span>
<span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">filter_cls</span><span class="p">,</span> <span class="n">output_cls</span><span class="p">),</span> <span class="p">{})</span>

<span class="c1"># Call it as usual to produce an instance.</span>

<span class="n">logger</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>The tuple of classes passed to <code class="docutils literal notranslate"><span class="pre">type()</span></code>
has the same meaning
as the series of base classes in a <code class="docutils literal notranslate"><span class="pre">class</span></code> statement.
The <code class="docutils literal notranslate"><span class="pre">type()</span></code> call above creates a new class
through multiple inheritance from both a filtered logger and an output logger.</p>
<p>Before you ask:
yes,
it would also work
to build a <code class="docutils literal notranslate"><span class="pre">class</span></code> statement as plain text
and then pass it to <code class="docutils literal notranslate"><span class="pre">eval()</span></code>.</p>
<p>But building classes on-the-fly carries severe liabilities.</p>
<ul class="simple">
<li><p>Readability suffers.
A human reading the above snippet of code
will have to do extra work
to determine what sort of object an instance of <code class="docutils literal notranslate"><span class="pre">cls</span></code> is.
Also, many Python programmers
aren’t familiar with <code class="docutils literal notranslate"><span class="pre">type()</span></code>
and will need to stop and puzzle over its documentation.
If they have difficulty with the novel concept
that classes can be defined dynamically,
they might still be confused.</p></li>
<li><p>If a constructed class like <code class="docutils literal notranslate"><span class="pre">PatternFilteredFileLog</span></code>
is named in an exception or error message,
the developer will probably be unhappy to discover
that nothing comes up when they search the code for that class name.
Debugging becomes more difficult
when you cannot even locate a class.
Considerable time may be spent
searching the codebase for <code class="docutils literal notranslate"><span class="pre">type()</span></code> calls
and trying to determine which one generated the class.
Sometimes developers have to resort
to calling each method with bad arguments
and using the line numbers in the resulting tracebacks
to track down the base classes.</p></li>
<li><p>Type introspection will, in the general case,
fail for classes constructed dynamically at runtime.
“Jump to class” shortcuts in your editor
won’t have anywhere to take you
when you highlight an instance of <code class="docutils literal notranslate"><span class="pre">PatternFilteredFileLog</span></code>
in the debugger.
And type checking engines like
<a class="reference external" href="https://github.com/python/mypy">mypy</a>
and <a class="reference external" href="https://github.com/facebook/pyre-check">pyre-check</a>
will be unlikely to offer the strong protections for your generated class
that they’re able to provide
for normal Python classes.</p></li>
<li><p>The beautiful Jupyter Notebook feature <code class="docutils literal notranslate"><span class="pre">%autoreload</span></code>
possesses a nearly preternatural ability
to detect and reload modified source code in a live Python interpreter.
But it’s foiled, for example, by the multiple inheritance classes
that <a class="reference external" href="https://github.com/matplotlib/matplotlib/blob/54b426397c0e7567edaee4f7f77036c2b8569573/lib/matplotlib/axes/_subplots.py#L180">matplotlib builds at runtime</a>
through <code class="docutils literal notranslate"><span class="pre">type()</span></code> calls inside its <code class="docutils literal notranslate"><span class="pre">subplot_class_factory()</span></code>.</p></li>
</ul>
<p>Once its liabilities are weighed,
the attempt to use runtime class generation as a last-ditch maneuver
to rescue the already faulty mechanism of multiple inheritance
stands as a <em>reductio ad absurdum</em>
of the entire project of dodging Composition Over Inheritance
when you need an object’s behavior
to vary over several independent axes.</p>
</section>
</section>

    </article>
    <hr>
    <p class="copyright">
      © 2018–2020 <a href="http://rhodesmill.org/brandon/">Brandon Rhodes</a>
    </p>
  </body>
</html>